<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>realazy: JavaScript 数组的 uniq 方法</title><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/assets/style.css" type="text/css"/><link rel="stylesheet" href="/assets/fonts.css" type="text/css" media="none" onload="if(media!='all') media='all'"/></head><body id="post">
       <header>
        <h1>JavaScript 数组的 uniq 方法</h1>
        <p>
          <a href="/">真・懒</a>写于<time datetime="2007-12-07">二〇〇七年十二月七日</time>
        </p>
      </header>
      <main> 
        <p>来自某个nb招聘的题目：</p>
<p>请给Array本地对象增加一个原型方法，它的用途是删除数组条目中重复的条目(可能有多个)，返回值是一个包含被删除的重复条目的新数组。这是我的答案：</p>
<h2 id="_1">新解</h2>

<pre><code>Array.prototype.uniq = function(){
    var resultArr = [],
        returnArr = [],
        i = 1,
        origLen = this.length,
        resultLen;
    function include(arr, value){
        for (var i=0, n=arr.length; i&lt;n; ++i){
            if (arr[i] === value){
                return true;
            }
        }
        return false;
    }
    resultArr.push(this[0]);
    for (i; i&lt;origLen; ++i){
        if (include(resultArr, this[i])){
            returnArr.push(this[i]);
        } else {
            resultArr.push(this[i]);
        }
    }
    resultLen = resultArr.length;
    this.length = resultLen;
    for (i=0; i&lt;resultLen; ++i){
        this[i] = resultArr[i];
    }
    return returnArr;
}</code></pre><p>这种解法在整个过程对原有数组的改变只有两次，效率比其他两种高了2个数量级左右！可<a href='http://realazy.com/lab/uniq.html'>在此测试</a>三种解法的性能。</p>
<h2 id="_2">旧解</h2>

<p>以下至&quot;关于测试案例&quot;之间皆为旧文，若阅读不顺，忽略之。</p>
<pre><code>Array.prototype.uniq_slow = function(){
    var ret = [],
        i = 0,
        j = 0;
    while (undefined !== this[i]){
        j = i + 1;
        while(undefined !== this[j]){
            if (this[i] === this[j]){
                ret.push(this.splice(j, 1)[0]);
            } else {
                ++j;
            }
        }
        ++i;
    }
    return ret;
}</code></pre><p>感谢猫仔提示，这道题目很容易让人产生误读。看清了题目后更新了。</p>
<p>为何用 <code>while</code> 而不是 <code>for</code>? 因为这个数组总是在变化，每次循环都得重新计算 <code>length</code>. 按理说，使用 <code>while</code> 效率会更高，尤其数组很大的时候。</p>
<p>欢迎大家交流讨论。</p>
<p>感谢 fdcn 提示，更新之。这里确实是容易犯错。</p>
<p>猜想由于强类型判断导致性能不高（可<a href='http://realazy.com/lab/uniq.html'>在此测试</a>），因此此种做法未见有性能的提升（还稍微慢了一些），而且还不能传递类似 <code>[1,,,2,,]</code> 这样的数组。所以还是<a href='http://ued.taobao.com/blog/2007/11/20/job_test_explanation/'>淘宝UED上的解法</a>比较科学（当然不是没有改进之处，比如不应该在 <code>for</code> 循环中声明变量）。</p>
<p>其实，这篇blog的意义在探讨如何避免无意义的消耗（比如计算 <code>length</code>）。但是鱼和熊掌不能兼得是自古之理，顾此失彼。当然，办法不是没有，比如数组的 <code>forEach</code>, <code>map</code> 方法等，可惜只有 <code>gecko</code> 浏览器才支持。</p>
<h2 id="_3">关于测试案例</h2>

<p>数组是随机产生的1-100之间的整数，长度为5000，每个相同的大约重复5次。三个测试数组的元素构成是一致的。</p>
<h2 id="_4">总结</h2>

<p>对数组的改变开销巨大，如果可能，尽量在不改变原有数组的情况下进行操作，如最终需要改变数组自身，可将结果赋予原有数组来操作。另外，对于 <code>length</code> 的计算，似乎效率并未受其影响。</p>
<p>啥时候我也该进补算法了，唉。软肋啊。</p>
<p><strong>推荐阅读：</strong> 王元涛同学的<a href='http://www.pkblogs.com/todwang/2007/12/javascript-uniq.html'>JavaScript 数组的 uniq 方法</a>。</p>

      </main>
       <footer>
         <p>2005 ～ 2017 © <span><a href="/">realazy</a></span> <span><a href="https://twitter.com/_cxa">Twitter</a></span> <span><a href="https://github.com/cxa">GitHub</a></span></p>
       </footer>
     </body></html>